##### 1、scanf和scanf_s

 scanf_s() 的功能虽然与scanf() 相同，但却比 scanf() 安全，因为 scanf_s() 是针对“ scanf()在读取字符串时不检查边界，可能会造成内存泄露”这个问题设计的。
scanf_s()用于读取字符串时，必须提供一个数字以表明最多读取多少位字符，以防止溢出。 

~~~c
void main()
  {
   char buffer[128];                               
   printf("Please input a string:\n");
   scanf_s("%s" , buffer,128);                     
    /*   这里必须要有128，以表明最多读取128个字符，如果写成scanf_s("%s",buffer)，程序将无法执     行到底，且编译器会提示“Unhandled exception at 0xfefefefe in array.exe:0xC0000005:       Access tion.” 。当然在安全性要求不高的情况下，不 一定非要用scanf_s()函数，可用               scanf("%s",buffer)代替。  */
    printf("%d vowels appear in your string.\n",CountVowel(buffer));
    system("pause");
   }
~~~

<!--注：三个小波浪可以插入代码块-->

##### 2、print、println、printf

print--是函数，可以返回一个值，只能有一个参数。

println--与print唯一的区别是println换行输出。

printf--函数，把文字格式化以后输出，直接调用系统调用进行IO的，他是非缓冲的。

 sprintf--跟printf相似，但不打印，而是返回格式化后的文字，其他的与printf一样 

 sprintf(sql,"select * from table where no = '%s'",bankno);
它的功能只是把""里面的语句赋给了变量sql。 

print将它的参数显示在命令窗口，并将输出光标定位在所显示的最后一个字符之后。

println 将它的参数显示在命令窗口，并在结尾加上换行符，将输出光标定位在下一行的开始。

printf是格式化输出的形式。

这里的"%.2f"的意思是输出两位小数点。如果想输出三位那就"%.3f"。

 在"%"与"d"之间加个数5的意思是输出5个占位符 

printf可以控制输出的格式。

##### 3、浮点数

整数的运算结果还是整数

##### 4、交换两个变量

临时变量

##### 5、++ -- 运算符

~~~	c
int a = 10;	
printf("a++=%d\n", a++);
//输出10
printf("%d\n", a);
//输出11
printf("++a=%d\n", ++a);
//输出12
printf("%d", a);
//输出12
~~~

##### 6、if-else常见错误

##### 7、switch-case

switch的参数必须是int类型的结果，不能为double之类的

##### 8、随机函数

rand（）

##### 9、整数的分解

a、%10操作——得到个位数



b、/10操作——去掉个位数

c、对b的结果进行%10操作，得到原来的十位数



##### 10、循环

如果有固定次数，用for

如果必须执行一次，用do_while

其他情况用while

##### 11、goto语句

~~~c
for(...) {
   for(...) {
      while(...) {
         if(...) goto stop;
         .
         .
         .
      }
   }
}
stop:
cout << "Error in program.\n";
~~~

##### 12、逆序输出

##### 13、整除和取余

a % b 
如果a<b的话，这样的商为0,余数就是a 

-3/16,16/-3，-3%16,16%-3的值各为多少?

除号的正负取舍和一般的算数一样，符号相同为正，相异为负
求余符号的正负取舍和被除数符号相同
-3/16=0   16/-3=-5   -3%16=-3   16%-3=1

##### 14、最大公约数

a、b

如果b为0，则计算结束，a就是最大公约数，否则，计算a除以b的余数，让a等于b，而b为余数的值，继续进行

 2413=1397*1+1016，
1397=1016*1+381，
1016=381*2+254，
381=254*1+127，
254=127*2+0，
所以（1397，2413）=127。 



##### 15、数据类型

char（1字节），short（2字节）

int、long、double

输入输出时的格式化：%d，%ld，%lf

所表达的数的范围：char<short<int<float<double

sizeof()占据内存的空间， sizeof是C语言中保留关键字，也可以认为是一种运算符，单目运算符 

<!--注：sizeof是静态运算符，它的结果在编译时刻就决定了，不要在sizeof的括号里做运算，这些运算不会被执行。-->

 C/C++中，sizeof()只是运算符号，是==编译的时候确定大小==的。动态分配是运行过程中得到大小的，也就是说C++中new出来的内存，sizeof都无法统计的，退一步说，即使时new出来的空间也有可能失败，所以sizeof无法统计动态分配的内存大小。 

##### 16、char和int

~~~c
#include <stdio.h>
 
int main(int argc, const char * argv[]) {
    char c1 = 255;
    printf("%d\n",c1);
    return 0;
}
~~~

分析：

255 是一个整数，==在计算机中, 数字存其补码==, 正数的原反补都是其本身

这里不妨将 255 看成一个 int  占用4个房间（字节）：

                    0000 0000 0000 0000 0000 0000 1111 1111  原码
    
                    0000 0000 0000 0000 0000 0000 1111 1111  反码
    
                    0000 0000 0000 0000 0000 0000 1111 1111  补码    [计算机中存储格式]  
    
                    ---------------------------------------------------------------------------------------------------------------------
    
                    这个时候，计算机用 char 的眼光 来看这个 1111 1111   【负数由补码求原码】
    
                     补码：1 111 1111 
    
                     中间：1 111 1110    减1      //先减去1 
    
                     原码：1 000 0001  取反    // 符号位不变，取反，得到所谓的原码  

所以结果为 -1     

结论：不管怎么去存，只管怎么去读。

           1111 1111   用   int 的视角去翻译，它就是 255；用 char 的视角去翻译，它就是 -1


##### 17、字符类型

char m=197;　　              -->?      //输出字符编码表中对应的字符。

char m='197;　　             -->报错    //因为有单引号，表示是字符，只允许放单个字符。

  'a'-'A'=32可以得到两段之间的距离（97-65=32）

a+('a'-'A')可以把一个大写字母变成小写字母

a-('a'-'A')可以把一个小写字母变成大写字母

例如：

输入为'a'则减去32得到'A'为65。输入'A'加上32得到97即'A'

##### 18、逃逸字符

\t——相对于tab	

\r——回车	

\n——换行

\d——回退一格

##### 19、类型转换



















































